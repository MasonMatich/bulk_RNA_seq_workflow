---
title: "analysis"
output: html_document
---

# `r sprintf("%d. %s Analysis", sample_idx, sample_params$sample_title) ` {.title}

Metadata information received from the tsv table:
```{r report_inputs_tsv, warning=FALSE, message=FALSE, echo=FALSE}
print(metadata)
```

## Analysis Methods
Here, count data from the RNA-seq experiment is read in the form of a counts matrix. Each column holds data from one sample, and each row represents a gene, such that the i-th row and n-th column tells how reads of gene i were measured in sample n.
The values received should be un-normalized counts of sequencing reads or fragments.
```{r read_in_counts_matrix_prep, warning=FALSE, message=FALSE}
# # Read Count Matrix
counts_file <- trimws(sample_params$salmon_merged_gene_counts_file_path)
```


```{r read_in_counts_matrix_file_validation, warning=FALSE, message=FALSE, echo=FALSE}
# Validate file exists
if (!file.exists(counts_file)) {
  stop(sprintf("❌ Count matrix file not found: %s\nPlease check the path in sampleInfo.csv", counts_file))
}

# Check file size
file_size_mb <- file.size(counts_file) / 1e6
if (file_size_mb > 500) {
  cat(sprintf("⚠️  Large count matrix (%.1f MB). Loading may take time...\n", file_size_mb))
}
```


```{r read_in_counts_matrix, warning=FALSE, message=FALSE}
count.matrix <- read_tsv(counts_file)
```


```{r read_in_counts_matrix_structure_validation, warning=FALSE, message=FALSE, echo=FALSE}
# Validate count matrix structure
if (!"gene_id" %in% colnames(count.matrix)) {
  stop("❌ Count matrix must have a 'gene_id' column")
}

if (ncol(count.matrix) < 3) {
  stop(sprintf("❌ Count matrix has only %d columns. Expected at least 3 (gene_id, gene_name, and sample data)",
               ncol(count.matrix)))
}
```


```{r restructure_counts_matrix, warning=FALSE, message=FALSE}
count.matrix <- count.matrix %>%
  mutate(across(3:ncol(.), ~ as.integer(.x))) %>%
  column_to_rownames("gene_id")

gene.reference <- dplyr::select(count.matrix, 1)

count.matrix <- count.matrix %>%
  dplyr::select(-1)
```

```{r inputval_meta_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check for agreement in cond_col_name and num_cond
if (nrow(metadata) != (ncol(count.matrix))){
  stop("number of rows entered as metadata doesn't match number of columns in count matrix.")
}
```

Information entered as metadata describes the samples (columns) of the count matrix. This metadata is combined with the sample/column names from the count matrix so the accuracy of the metadata can be reviewed. Take time to review the table below.
```{r DESeq2_design_coldata, warning=FALSE, message=FALSE}
# Design ColData Matrix
sample <- colnames(count.matrix)
colData <- data.frame(sample)

# Add Columns for Condition to colData
for (i in colnames(metadata)){
  colData[i] <- metadata[i]
}

colData <- column_to_rownames(colData, "sample")
```

```{r report_colData,warning=FALSE, message=FALSE, echo=FALSE}
print(as.matrix(colData))
```

```{r inputval_colData_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check matrix design against count matrix columns
if(all(colnames(count.matrix) != rownames(colData))){
  stop(sprintf("The structure of the colData matrix doesn't match the structure of the count matrix.\n   The received colData is %s.\n   The received count matrix columns are %s", rownames(colData), colnames(count.matrix)))
}
```

Using the count matrix, column metadata, and user-inputed design formula (expressing the variables to be used in modeling), a DESeq data set is created.

The experimental variable and the associated control/experimental conditions are given by the user in "ref_level_cond" and "ref_level_value" in the sampleInfo file respectively.

Pre-filtering is performed, keeping only genes that have a count of at least 10 in a minimum number of samples. The minimum number of samples is decided by calculating the number of times the reference level value (control condition) is listed in the metadata with the assumption that experimental conditions will be repeated the same number of times.

Standard differential expression analysis is performed with the DESeq function, and regularized log transformation (rlog) transforms count data to a log2 scale for PCA.
```{r DESeq2_prep, warning=FALSE, results='hide', message=FALSE}
# Set Reference Level
reflevelcond <- trimws(sample_params$ref_level_cond)
reflevelvalue <- trimws(sample_params$ref_level_value)
```


```{r DESeq2_run_validation, warning=FALSE, results='hide', message=FALSE, echo=FALSE}
# Validate that ref_level_cond exists in metadata
if (!reflevelcond %in% colnames(metadata)) {
  stop(sprintf("❌ Reference level condition '%s' not found in metadata columns.\n   Available columns: %s",
               reflevelcond, paste(colnames(metadata), collapse=", ")))
}

# Validate that ref_level_value exists in the reference condition
if (!reflevelvalue %in% metadata[[reflevelcond]]) {
  stop(sprintf("❌ Reference level value '%s' not found in metadata column '%s'.\n   Available values: %s",
               reflevelvalue, reflevelcond, paste(unique(metadata[[reflevelcond]]), collapse=", ")))
}
```


```{r DESeq2_run, warning=FALSE, results='hide', message=FALSE}
# Run DESeq2 analysis
deseq_result <- runDESeq2Analysis(
  count.matrix = count.matrix,
  colData = colData,
  design = sample_params$design,
  ref_level_cond = reflevelcond,
  ref_level_value = reflevelvalue,
  metadata = metadata
)

dds <- deseq_result$dds
rld <- deseq_result$rld
```

If input data is designated to be batch corrected, the ComBat_seq() function from the SVA Bioconductor package is used. The batch (condition) to be regressed out is given in sampleInfo.csv as "batch_cond", and the sample information for this condition is taken from the metadata.

The group argument of ComBat_seq() specifies biological covariates, whos signals should be preserved in adjusted data. All conditions (columns) from the metadata which are not to be regressed out are passed to the group argument.
Differential expression analysis is otherwise performed as described above on batch-corrected counts.

```{r DESeq2_run_batch_validation, warning=FALSE, message=FALSE, echo=FALSE}
if (as.logical(trimws(sample_params$batch_correct))) {
  # Check that condition for batch correction matches column metadata
  if(all(trimws(sample_params$batch_cond) != colnames(metadata))){
    stop(sprintf("The given condition for batch correction:%s, doesn't match any prior conditions: %s", sample_params$batch_cond, colnames(metadata)))
  }
}
```

```{r DESeq2_run_batch, warning=FALSE, results='hide', message=FALSE, echo = (as.logical(trimws(sample_params$batch_correct)))}
if (as.logical(trimws(sample_params$batch_correct))) {
  # Replicate / Batch Correction
  batch <- trimws(sample_params$batch_cond)

  batch.correct <- ComBat_seq(
    counts = as.matrix(count.matrix),
    batch = metadata[[batch]],
    group = metadata[[colnames(metadata)[colnames(metadata) != batch]]]) %>%
    as.data.frame()

  # Run DESeq2 analysis on batch-corrected counts
  batch_deseq_result <- runDESeq2Analysis(
    count.matrix = batch.correct,
    colData = colData,
    design = sample_params$design,
    ref_level_cond = reflevelcond,
    ref_level_value = reflevelvalue,
    metadata = metadata
  )

  batch.correct.dds <- batch_deseq_result$dds
  batch.correct.rld <- batch_deseq_result$rld
  
  # Cleanup
  rm(batch, batch.correct, keep)
}
```

Reference level condition and value (ref_level_cond and ref_level_value respectively) inputs from sampleInfo.csv are used to create contrast terms to compare treatment samples with control samples. This relies on the design formula being formatted correctly to produce comparisons relevant to the experimental condition.
```{r DESeq2_contrasts, warning=FALSE, message=FALSE, results='hide'}
# # Find relevant contrasts
contrasts <- list()

# Factor values of experimental condition
pattern <- factor(metadata[[reflevelcond]])
comp <- levels(pattern)

# Remove control state from experimental condition vector
comp <- comp[comp != reflevelvalue]

# Create Contrasts
for (i in 1:length(comp)){
  contrasts[[i]] <- c(reflevelcond, comp[i], reflevelvalue)
}
```

```{r DESeq2_batch_select, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Select non-batch corrected dds for further analysis
dds.for.analysis <- dds

# Select batch corrected dds for further analysis if sample_info$batch_correct = TRUE
if (as.logical(trimws(sample_params$batch_correct))){
  dds.for.analysis <- batch.correct.dds
}
```

Based on the number of experimental conditions (identified in the ref_level_cond column of the metadata) and the contrast terms comparing them to the experimental control (ref_level_value), differential expression results are extracted from the DESeq data set object.
```{r DESeq2_get_results, warning=FALSE, message=FALSE, results='hide'}
# Find results from relevant contrasts
results <- list()

# Pull results from DESeq object with contrasts
for (i in 1:length(contrasts)){
  results[[i]] <- list()
  results[[i]][["DataFrame"]] <- results(dds.for.analysis, contrast = contrasts[[i]]) %>%
    data.frame() %>%
    rownames_to_column("gene_id") %>%
    mutate(gene_name = gene.reference[gene_id, 1], .before=baseMean) %>% # Add gene names to DESeq results matrices
    column_to_rownames("gene_id")
  
  results[[i]][["DESeqDataSet"]] <- results(dds.for.analysis, contrast = contrasts[[i]])
}
```

## Principle Component Analysis
The Bioconductor package PCAtools is used to perform principle component analysis on regularized log transformed count data. 
Scree plots show principle component numbers on the x-axis, and their respective eigenvalues on the y-axis.

The third graph plots experimental metadata against a number of PCs and their gene loadings to visualize the agreement with the gene expression pattern of each condition for each PC.

### No Regression
```{r PCA_report, warning=FALSE, message=FALSE, results='hide', echo=FALSE, out.width="90%", fig.align="center"}
# View non-batch corrected
pca <- visualizePCsByCondition(
  rlog = rld,
  metadata = colData,
  title = ""
  )
pca$logScaleScree | pca$linearScaleScree
```

```{r PCA_report_2, warning=FALSE, message=FALSE, results='hide', echo=FALSE, out.width="80%", fig.align="center"}
pca$selectedPCs
```


```{r PCA_batch_report_header, warning=FALSE, message=FALSE, results='asis', echo = FALSE}
if(as.logical(trimws(sample_params$batch_correct))){
  cat(sprintf("\n\n###%s Regressed Out", str_to_title(sample_params$batch_cond)))
}
```

```{r PCA_batch_report, warning=FALSE, message=FALSE, results='hide', echo = FALSE, out.width="90%", fig.align="center"}
# View Rep effect corrected
if(as.logical(trimws(sample_params$batch_correct))){
  pca.batch <- visualizePCsByCondition(
      rlog = batch.correct.rld,
      metadata = colData,
      title = ""
      )
  print(pca.batch$logScaleScree | pca.batch$linearScaleScree)
}
```

```{r PCA_batch_report_2, warning=FALSE, message=FALSE, results='hide', echo = FALSE, out.width="80%", fig.align="center"}
if(as.logical(trimws(sample_params$batch_correct))){
  print(pca.batch$selectedPCs)
}
```


```{r PCA_write_pdf, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Save PCA to PDF
pdf(file.path(project_dirs$figures, sprintf("%s_PCA.pdf", trimws(sample_params$sample_name))))

# View non-batch corrected
pca$logScaleScree
pca$linearScaleScree
pca$selectedPCs

if(as.logical(trimws(sample_params$batch_correct))){
  # View Rep effect corrected
pca.batch$logScaleScree
pca.batch$linearScaleScree
pca.batch$selectedPCs
}

dev.off()
```

```{r save_data, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# #                               Save Files                                # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Save DESeq Output using robust paths
sample_name_clean <- trimws(sample_params$sample_name)
saveRDS(dds, file = file.path(project_dirs$results, sprintf("%s_dds.rds", sample_name_clean)))
saveRDS(rld, file = file.path(project_dirs$results, sprintf("%s_rld.rds", sample_name_clean)))

# Save Batch Corrected DESeq Output
if(as.logical(trimws(sample_params$batch_correct))){
  saveRDS(batch.correct.dds, file = file.path(project_dirs$results, sprintf("%s_batch_correct_dds.rds", sample_name_clean)))
  saveRDS(batch.correct.rld, file = file.path(project_dirs$results, sprintf("%s_batch_correct_rld.rds", sample_name_clean)))
}

# Cleanup
rm(dds, batch.correct.dds, rld, batch.correct.rld, colData, count.matrix, comp, pattern, sample, reflevelcond, reflevelvalue, metadata, pca, pca.batch, smallest.group.size)
```

```{r compile_report, results='asis', warning=FALSE, message=FALSE, echo=FALSE}
for (i in 1:length(results)){
  compileReport(
    result.obj = results[[i]],
    contrast = sprintf("%s_%s_vs_%s", contrasts[[i]][1], contrasts[[i]][2], contrasts[[i]][3]),
    sample_name = trimws(sample_params$sample_name),
    l2fc_filter = as.numeric(trimws(sample_params$l2fc_filter)),
    padj_filter = as.numeric(trimws(sample_params$padj_filter)),
    semantic_data = semantic_data,
    OrgDb = org.Ce.eg.db)
}
```