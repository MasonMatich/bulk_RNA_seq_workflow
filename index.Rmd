---
params:
  dynamic_title: "Bulk RNA-seq Report"
  project: 
  params_file: "sample_params"
  metadata: "metadata_table"
title: "`r params$dynamic_title`"
author: "Mason Matich (masonmatich@gmail.com)"
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 3
    number_sections: FALSE
---

Many of the figures and analysis methodology were based off of this tutorial from NYU.
https://learn.gencore.bio.nyu.edu/rna-seq-analysis/gene-set-enrichment-analysis/

```{r library_setup, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# # Library Preparation
# Cran or base R packages required
cranr <- c("bookdown", "dplyr", "DT", "knitr",  "kableExtra", "ashr", "htmltools", "ggplot2", "PCAtools", "knitrBootstrap")

# Check if the packages are installed if not install
cranr.new <- cranr[!(cranr%in%installed.packages())]
if (length(cranr.new)) {
  install.packages(cranr.new)
}

# List of bioconductor packages required
bioconductor<-c("ReactomePA", "clusterProfiler", "DESeq2", "GOSemSim", "sva", "vsn", "org.Ce.eg.db", "EnhancedVolcano")

# Check if the packages were installed if not install
bioconductor.new <- bioconductor[!(bioconductor%in%installed.packages())]
if (length(bioconductor.new)) {
  if (!requireNamespace("BiocManager")) {
    install.packages("BiocManager")
  }
  BiocManager::install(bioconductor.new, type="source")
}
# load required packages
sapply(cranr.new, library, character.only = TRUE)
sapply(bioconductor.new, library, character.only = TRUE)
```
```{r warning=FALSE, message=FALSE, echo=FALSE}
rm(bioconductor, bioconductor.new, cranr, cranr.new)
```

```{r datatable_dependencies, warning=FALSE, message=FALSE, include=FALSE}
# Loads dependences needed to render other datatables
datatable(data.frame(x = c(1), y = c(1)), extensions = 'Buttons', rownames = FALSE,options = list(buttons = c('copy', 'csv', 'excel', 'pdf')))
```

```{r params_setup, warning=FALSE, message=FALSE, echo=FALSE}
# # Read in Params
#sample_params <- read.csv(params$params_file)
#metadata <- read.table(params$metadata, header = T)
sample_params <- read.csv("scripts/chen_phillips_sampleInfo.csv")
metadata <- read.table("scripts/metadata.txt", header = T)
```

```{r function_setup, warning=FALSE, message=FALSE, echo=FALSE}
# # Read in functions
source("scripts/translateBioIDs.R")
source("scripts/callClusterProfilerFunc.R")
source("scripts/compileReport.R")
source("scripts/emptyTableMessage.R")
source("scripts/visualizePCsByCondition.R")
source("scripts/knitDataTable.R")
```

# DESeq2 Differential Expression Analysis {.title}

## Inputs Received
Information received from the csv samplesheet:
```{r report_inputs_csv, warning=FALSE, message=FALSE, echo=FALSE}
datatable(as.data.frame(sample_params), rownames = FALSE, options = list(dom = "rt", scrollX = TRUE))
```
Metadata information received from the tsv table:
```{r report_inputs_tsv, warning=FALSE, message=FALSE, echo=FALSE}
print(metadata)
```

## Analysis Methods
Here, count data from the RNA-seq experiment is read in the form of a counts matrix. Each column holds data from one sample, and each row represents a gene, such that the i-th row and n-th column tells how reads of gene i were measured in sample n.
The values received should be un-normalized counts of sequencing reads or fragments.
```{r read_in_counts_matrix, warning=FALSE, message=FALSE}
# # Read Count Matrix
count.matrix <- read_tsv(trimws(sample_params$salmon_merged_gene_counts_file_path)) %>%
  mutate(across(3:ncol(.), ~ as.integer(.x))) %>%
  column_to_rownames("gene_id")

gene.reference <- dplyr::select(count.matrix, 1)

count.matrix <- count.matrix %>%
  dplyr::select(-1)
```

```{r inputval_meta_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check for agreement in cond_col_name and num_cond
if (nrow(metadata) != (ncol(count.matrix))){
  stop("number of rows entered as metadata doesn't match number of columns in count matrix.")
}
```
Information entered as metadata describes the samples (columns) of the count matrix. This metadata is combined with the sample/column names from the count matrix so the accuracy of the metadata can be reviewed. Take time to review the table below.
```{r DESeq2_design_coldata, warning=FALSE, message=FALSE}
# Design ColData Matrix
sample <- colnames(count.matrix)
colData <- data.frame(sample)

# Add Columns for Condition to colData
for (i in colnames(metadata)){
  colData[i] <- metadata[i]
}

colData <- column_to_rownames(colData, "sample")
```

```{r report_colData,warning=FALSE, message=FALSE, echo=FALSE}
print(as.matrix(colData))
```

```{r inputval_colData_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check matrix design against count matrix columns
if(all(colnames(count.matrix) != rownames(colData))){
  stop(sprintf("The structure of the colData matrix doesn't match the structure of the count matrix.\n   The received colData is %s.\n   The received count matrix columns are %s", rownames(colData), colnames(count.matrix)))
}
```
Using the count matrix, column metadata, and user-inputed design formula (expressing the variables to be used in modeling), a DESeq data set is created. 

The experimental variable and the associated control/experimental conditions are given by the user in "ref_level_cond" and "ref_level_value" in the params_file respectively. 

Pre-filtering is performed, keeping only genes that have a count of at least 10 in a minimum number of samples. The minimum number of samples is decided by calculating the number of times the reference level value (control condition) is listed in the metadata with the assumption that experimental conditions will be repeated the same number of times. 

Standard differential expression analysis is performed with the DESeq function, and regularized log transformation (rlog) transforms count data to a log2 scale for PCA.
```{r DESeq2_run, warning=FALSE, results='hide', message=FALSE}
# Create DESeq Data Set
dds <- DESeqDataSetFromMatrix(
  countData = count.matrix,
  colData = colData,
  design = as.formula(sample_params$design)
)

# Set Reference Level
reflevelcond <- trimws(sample_params$ref_level_cond)
reflevelvalue <- trimws(sample_params$ref_level_value)
dds[[reflevelcond]] <- relevel(dds[[reflevelcond]], ref = reflevelvalue)

# Subset out genes with low overall counts
smallest.group.size <- length(grep(sprintf("^%s$",reflevelvalue), metadata[[reflevelcond]]))
keep <- rowSums(counts(dds) >= 10) >= smallest.group.size
dds <- dds[keep,]

# Run DESeq
dds <- DESeq(dds)

# Regularized Log Transform
rld <- rlog(dds)
```
If input data is designated to be batch corrected, the ComBat_seq() function from the SVA Bioconductor package is used. The batch (condition) to be regressed out is given in the params_file as "batch_cond", and the sample information for this condition is taken from the metadata. 

The group argument of ComBat_seq() specifies biological covariates, whos signals should be preserved in adjusted data. All conditions (columns) from the metadata which are not to be regressed out are passed to the group argument.
Differential expression analysis is otherwise performed as described above on batch-corrected counts. 
```{r DESeq2_run_batch, warning=FALSE, results='hide', message=FALSE, echo = (as.logical(trimws(sample_params$batch_correct)))}
if (as.logical(trimws(sample_params$batch_correct))) {
  
  # Check that condition for batch correction matches column metadata
  if(all(trimws(sample_params$batch_cond) != colnames(metadata))){
    stop(sprintf("The given condition for batch correction:%s, doesn't match any prior conditions: %s", sample_params$batch_cond, colnames(metadata)))
  }
  
  # Replicate / Batch Correction
  batch <- trimws(sample_params$batch_cond)
  
  batch.correct <- ComBat_seq(
    counts = as.matrix(count.matrix),
    batch = metadata[[batch]],
    group = metadata[[colnames(metadata)[colnames(metadata) != batch]]]) %>%
    as.data.frame()

  # Create DESeq Data Set
  batch.correct.dds <- DESeqDataSetFromMatrix(
    countData = batch.correct,
    colData = colData,
    design = as.formula(sample_params$design))
  
  # Set Factor Level
  reflevelcond <- trimws(sample_params$ref_level_cond)
  reflevelvalue <- trimws(sample_params$ref_level_value)
  batch.correct.dds[[reflevelcond]] <- relevel(batch.correct.dds[[reflevelcond]], ref = reflevelvalue)
  
  # Subset out genes with low overall counts
  smallest.group.size <- length(grep(sprintf("^%s$",reflevelvalue), metadata[[reflevelcond]]))
keep <- rowSums(counts(batch.correct.dds) >= 10) >= smallest.group.size
  batch.correct.dds <- batch.correct.dds[keep,]
  
  # Run DESeq
  batch.correct.dds <- DESeq(batch.correct.dds)
  
  # Regularized Log Transform
  batch.correct.rld <- rlog(batch.correct.dds)
}
```

```{r cleanup_2, warning=FALSE, message=FALSE, echo=FALSE}
# Cleanup
rm(batch, batch.correct, keep)
```
Reference level condition and value (ref_level_cond and ref_level_value respectively) inputs from params_file are used to create contrast terms to compare treatment samples with control samples. This relies on the design formula being formatted correctly to produce comparisons relevant to the experimental condition.
```{r DESeq2_contrasts, warning=FALSE, message=FALSE, results='hide'}
# # Find relevant contrasts
contrasts <- list()

# Factor values of experimental condition
pattern <- factor(metadata[[reflevelcond]])
comp <- levels(pattern)

# Remove control state from experimental condition vector
comp <- comp[comp != reflevelvalue]

# Create Contrasts
for (i in 1:length(comp)){
  contrasts[[i]] <- c(reflevelcond, comp[i], reflevelvalue)
}
```

```{r DESeq2_batch_select, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Select non-batch corrected dds for further analysis
dds.for.analysis <- dds

# Select batch corrected dds for further analysis if params$batch_correct = TRUE
if (as.logical(trimws(sample_params$batch_correct))){
  dds.for.analysis <- batch.correct.dds
}
```
Based on the number of experimental conditions (identified in the ref_level_cond column of the metadata) and the contrast terms comparing them to the experimental control (ref_level_value), differential expression results are extracted from the DESeq data set object.
```{r DESeq2_get_results, warning=FALSE, message=FALSE, results='hide'}
# Find results from relevant contrasts
results <- list()

# Pull results from DESeq object with contrasts
for (i in 1:length(contrasts)){
  results[[i]] <- list()
  results[[i]][["DataFrame"]] <- results(dds.for.analysis, contrast = contrasts[[i]]) %>%
    data.frame() %>%
    rownames_to_column("gene_id") %>%
    mutate(gene_name = gene.reference[gene_id, 1], .before=baseMean) %>% # Add gene names to DESeq results matrices
    column_to_rownames("gene_id")
  
  results[[i]][["DESeqDataSet"]] <- results(dds.for.analysis, contrast = contrasts[[i]])
}
```

# Principle Component Analysis {.title}
The Bioconductor package PCAtools is used to perform principle component analysis on regularized log transformed count data. 
Scree plots show principle component numbers on the x-axis, and their respective eigenvalues on the y-axis.

The third graph plots experimental metadata against a number of PCs and their gene loadings to visualize the agreement with the gene expression pattern of each condition for each PC.

## No Regression
```{r PCA_report, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# View non-batch corrected
pca <- visualizePCsByCondition(
  rlog = rld,
  metadata = colData,
  title = sprintf("Before Regressing out%s", params$batch_cond))

pca$logScaleScree
pca$linearScaleScree
pca$selectedPCs
```

```{r PCA_batch_report_header, warning=FALSE, message=FALSE, results='asis', echo = FALSE}
if(as.logical(trimws(sample_params$batch_correct))){
  cat(sprintf("\n\n##%s Regressed Out", sample_params$batch_cond))
}
```

```{r PCA_batch_report, warning=FALSE, message=FALSE, results='hide', echo = FALSE}
# View Rep effect corrected
if(as.logical(trimws(sample_params$batch_correct))){
  pca.batch <- visualizePCsByCondition(
      rlog = batch.correct.rld,
      metadata = colData,
      title = sprintf("After Regressing out%s", params$batch_cond))
  
  print(pca.batch$logScaleScree)
  print(pca.batch$linearScaleScree)
  print(pca.batch$selectedPCs)
}
```

```{r PCA_write_pdf, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Save PCA to PDF
pdf(sprintf("figures/%s_PCA.pdf", params$project))

# View non-batch corrected
pca$logScaleScree
pca$linearScaleScree
pca$selectedPCs

if(as.logical(trimws(sample_params$batch_correct))){
  # View Rep effect corrected
pca.batch$logScaleScree
pca.batch$linearScaleScree
pca.batch$selectedPCs
}

dev.off()
```

```{r save_data, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# #                               Save Files                                # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

# Save DESeq Output
saveRDS(dds, file = sprintf("results/%s_dds.rds", params$project))
saveRDS(rld, file = sprintf("results/%s_rld.rds", params$project))

# Save Batch Corrected DESeq Output
if(as.logical(trimws(sample_params$batch_correct))){
  saveRDS(batch.correct.dds, file = sprintf("results/%s_batch_correct_dds.rds", params$project))
  saveRDS(batch.correct.rld, file = sprintf("results/%s_batch_correct_rld.rds", params$project))
}

# Cleanup
rm(dds, batch.correct.dds, rld, batch.correct.rld, colData, count.matrix, comp, pattern, sample, reflevelcond, reflevelvalue, metadata, pca, pca.batch)
```

```{r compile_report, results='asis', warning=FALSE, message=FALSE, echo=FALSE}
for (i in 1:length(results)){
  compileReport(
    result.obj = results[[i]], 
    contrast = sprintf("%s_%s_vs_%s", contrasts[[i]][1], contrasts[[i]][2], contrasts[[i]][3]), 
    l2fc_filter = 0.8,
    padj_filter = 0.1)
}
```

```{r cleanup_3, warning=FALSE, message=FALSE, echo=FALSE}
rm(contrasts, results, dds.for.analysis, gene.reference, i, sample_params, callClusterProfilerFunc, compileReport, translateBioIDs, emptyTableMessage, knitDataTable, visualizePCsByCondition)
```

