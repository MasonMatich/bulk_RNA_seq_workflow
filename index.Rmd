---
params:
  dynamic_title: "Bulk RNA-seq Report"
  project: 
  params_file: "sample_params"
  metadata: "metadata_table"
title: "`r params$dynamic_title`"
author: "Mason Matich (mason.matich@wsu.edu)"
date: "`r Sys.Date()`"
output: 
  html_document2:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 3
    number_sections: FALSE
---

Many of the figures and analysis methodology were based off of this tutorial from NYU.
https://learn.gencore.bio.nyu.edu/rna-seq-analysis/gene-set-enrichment-analysis/

```{r library_setup, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# # Library Preparation
# Cran or base R packages required
cranr <- c("bookdown", "dplyr", "DT", "knitr",  "kableExtra", "ashr", "htmltools", "ggplot2", "PCAtools", "presto")

# Check if the packages are installed if not install
cranr.new <- cranr[!(cranr%in%installed.packages())]
if (length(cranr.new)) {
  install.packages(cranr.new)
}

# List of bioconductor packages required
bioconductor<-c("ReactomePA", "clusterProfiler", "DESeq2", "GOSemSim", "sva", "vsn", "org.Ce.eg.db", "EnhancedVolcano")

# Check if the packages were installed if not install
bioconductor.new <- bioconductor[!(bioconductor%in%installed.packages())]
if (length(bioconductor.new)) {
  if (!requireNamespace("BiocManager")) {
    install.packages("BiocManager")
  }
  BiocManager::install(bioconductor.new, type="source")
}
# load required packages
sapply(cranr.new, library, character.only = TRUE)
sapply(bioconductor.new, library, character.only = TRUE)
```
```{r warning=FALSE, message=FALSE, echo=FALSE}
rm(bioconductor, bioconductor.new, cranr, cranr.new)
```

```{r params_setup, warning=FALSE, message=FALSE, echo=FALSE}
# # Read in Params
#sample_params <- read.csv(params$params_file)
#metadata <- read.table(params$metadata, header = T)
sample_params <- read.csv("scripts/chen_phillips_sampleInfo.csv")
metadata <- read.table("scripts/metadata.txt", header = T)
```

```{r function_setup, warning=FALSE, message=FALSE, echo=FALSE}
# # Read in functions
source("scripts/translateBioIDs.R")
source("scripts/callClusterProfilerFunc.R")
source("scripts/compileReport.R")
source("scripts/emptyTableMessage.R")
source("scripts/visualizePCsByCondition.R")
source("scripts/knitDataTable.R")
```

# DESeq2 Differential Expression Analysis {.title}
```{r read_in_counts_matrix, warning=FALSE, message=FALSE}
# # Read Count Matrix
count.matrix <- read_tsv(trimws(sample_params$salmon_merged_gene_counts_file_path)) %>%
  mutate(across(3:ncol(.), ~ as.integer(.x))) %>%
  column_to_rownames("gene_id")

gene.reference <- dplyr::select(count.matrix, 1)

count.matrix <- count.matrix %>%
  dplyr::select(-1)
```

```{r inputval_meta_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check for agreement in cond_col_name and num_cond
if (nrow(metadata) != (ncol(count.matrix))){
  stop("number of rows entered as metadata doesn't match number of columns in count matrix.")
}
```

```{r DESeq2_design_coldata, warning=FALSE, message=FALSE}
# Design ColData Matrix
sample <- colnames(count.matrix)
colData <- data.frame(sample)

# Add Columns for Condition to colData
for (i in colnames(metadata)){
  colData[i] <- metadata[i]
}

colData <- column_to_rownames(colData, "sample")
```

```{r inputval_colData_vs_counts, warning=FALSE, message=FALSE, echo=FALSE}
# # Input Validation
# Check matrix design against count matrix columns
if(all(colnames(count.matrix) != rownames(colData))){
  stop(sprintf("The structure of the colData matrix doesn't match the structure of the count matrix.\n   The received colData is %s.\n   The received count matrix columns are %s", rownames(colData), colnames(count.matrix)))
}
```

```{r DESeq2_run, warning=FALSE, results='hide', message=FALSE}
# Create DESeq Data Set
dds <- DESeqDataSetFromMatrix(
  countData = count.matrix,
  colData = colData,
  design = as.formula(sample_params$design)
)

# Set Reference Level
reflevelcond <- trimws(sample_params$ref_level_cond)
reflevelvalue <- trimws(sample_params$ref_level_value)
dds[[reflevelcond]] <- relevel(dds[[reflevelcond]], ref = reflevelvalue)

# Subset out genes with low overall counts
keep <- rowSums(counts(dds) >= 10) >= 4
dds <- dds[keep,]

# Run DESeq
dds <- DESeq(dds)

# Regularized Log Transform
rld <- rlog(dds)
```

```{r DESeq2_run_batch, warning=FALSE, results='hide', message=FALSE, echo = (as.logical(trimws(sample_params$batch_correct)))}
if (as.logical(trimws(sample_params$batch_correct))) {
  
  # Check that condition for batch correction matches column metadata
  if(all(trimws(sample_params$batch_cond) != colnames(metadata))){
    stop(sprintf("The given condition for batch correction:%s, doesn't match any prior conditions: %s", sample_params$batch_cond, colnames(metadata)))
  }
  
  # Replicate / Batch Correction
  batch <- trimws(sample_params$batch_cond)
  
  batch.correct <- ComBat_seq(
    counts = as.matrix(count.matrix),
    batch = metadata[[batch]],
    group = metadata[[colnames(metadata)[colnames(metadata) != batch]]]) %>%
    as.data.frame()

  # Create DESeq Data Set
  batch.correct.dds <- DESeqDataSetFromMatrix(
    countData = batch.correct,
    colData = colData,
    design = as.formula(sample_params$design))
  
  # Set Factor Level
  reflevelcond <- trimws(sample_params$ref_level_cond)
  reflevelvalue <- trimws(sample_params$ref_level_value)
  batch.correct.dds[[reflevelcond]] <- relevel(batch.correct.dds[[reflevelcond]], ref = reflevelvalue)
  
  # Subset out genes with low overall counts
  keep <- rowSums(counts(batch.correct.dds) >= 10) >= 4
  batch.correct.dds <- batch.correct.dds[keep,]
  
  # Run DESeq
  batch.correct.dds <- DESeq(batch.correct.dds)
  
  # Regularized Log Transform
  batch.correct.rld <- rlog(batch.correct.dds)
  
  # Cleanup
  rm(batch, batch.correct)
}

# Cleanup
rm(keep)
```

```{r DESeq2_contrasts, warning=FALSE, message=FALSE, results='hide'}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
#  Logic here uses the reference level condition and value inputs to create   #
#  contrast terms assumed to compare treatment samples with control samples   #

# # Find relevant contrasts
contrasts <- list()

# Factor values of experimental condition
pattern <- factor(metadata[[reflevelcond]])
comp <- levels(pattern)

# Remove control state from experimental condition vector
comp <- comp[comp != reflevelvalue]

# Create Contrasts
for (i in 1:length(comp)){
  contrasts[[i]] <- c(reflevelcond, comp[i], reflevelvalue)
}
```

```{r DESeq2_batch_select, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Find results from relevant contrasts
results <- list()

# Select non-batch corrected dds for further analysis
dds.for.analysis <- dds

# Select batch corrected dds for further analysis if params$batch_correct = TRUE
if (as.logical(trimws(sample_params$batch_correct))){
  dds.for.analysis <- batch.correct.dds
}
```

```{r DESeq2_get_results, warning=FALSE, message=FALSE, results='hide'}
# Pull results from DESeq object with contrasts
for (i in 1:length(contrasts)){
  results[[i]] <- list()
  results[[i]][["DataFrame"]] <- results(dds.for.analysis, contrast = contrasts[[i]]) %>%
    data.frame() %>%
    rownames_to_column("gene_id") %>%
    mutate(gene_name = gene.reference[gene_id, 1], .before=baseMean) %>% # Add gene names to DESeq results matrices
    column_to_rownames("gene_id")
  
  results[[i]][["DESeqDataSet"]] <- results(dds.for.analysis, contrast = contrasts[[i]])
}
```

# Principle Component Analysis {.title}
```{r PCA_report, warning=FALSE, message=FALSE, results='hide'}
# View non-batch corrected
pca <- visualizePCsByCondition(
  rlog = rld,
  metadata = colData,
  title = "Before Replicate Batch Correction")

pca$logScaleScree
pca$linearScaleScree
pca$selectedPCs
```

```{r PCA_batch_report, warning=FALSE, message=FALSE, results='hide', echo = (as.logical(trimws(sample_params$batch_correct)))}
# View Rep effect corrected
if(as.logical(trimws(sample_params$batch_correct))){
pca.batch <- visualizePCsByCondition(
    rlog = batch.correct.rld,
    metadata = colData,
    title = "After Replicate Batch Correction")

print(pca.batch$logScaleScree)
print(pca.batch$linearScaleScree)
print(pca.batch$selectedPCs)
}
```

```{r PCA_write_pdf, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# Save PCA to PDF
pdf(sprintf("figures/%s_PCA.pdf", params$project))

# View non-batch corrected
pca$logScaleScree
pca$linearScaleScree
pca$selectedPCs

if(as.logical(trimws(sample_params$batch_correct))){
  # View Rep effect corrected
pca.batch$logScaleScree
pca.batch$linearScaleScree
pca.batch$selectedPCs
}

dev.off()
```

```{r save_data, warning=FALSE, message=FALSE, results='hide', echo=FALSE}
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# #                               Save Files                                # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

# Save DESeq Output
saveRDS(dds, file = sprintf("results/%s_dds.rds", params$project))
saveRDS(rld, file = sprintf("results/%s_rld.rds", params$project))

# Save Batch Corrected DESeq Output
if(as.logical(trimws(sample_params$batch_correct))){
  saveRDS(batch.correct.dds, file = sprintf("results/%s_batch_correct_dds.rds", params$project))
  saveRDS(batch.correct.rld, file = sprintf("results/%s_batch_correct_rld.rds", params$project))
}

# Cleanup
rm(dds, batch.correct.dds, rld, batch.correct.rld, colData, count.matrix, comp, pattern, sample, reflevelcond, reflevelvalue, metadata, pca, pca.batch)
```

```{r datatable_dependencies, warning=FALSE, message=FALSE, include=FALSE}
# Doesn't render in bookdown, but loades dependences needed to render other datatables
datatable(data.frame(x = c(1), y = c(1)), extensions = 'Buttons', rownames = FALSE,options = list(buttons = c('copy', 'csv', 'excel', 'pdf')))
```

```{r compile_report, results='asis', warning=FALSE, message=FALSE, echo=FALSE}
for (i in 1:length(results)){
  compileReport(
    result.obj = results[[1]], 
    contrast = sprintf("%s_%s_vs_%s", contrasts[[i]][1], contrasts[[i]][2], contrasts[[i]][3]), 
    l2fc_filter = 0.8,
    padj_filter = 0.1)
}
```

```{r cleanup_2, warning=FALSE, message=FALSE, echo=FALSE}
rm(contrasts, results, dds.for.analysis, gene.reference, i, sample_params, callClusterProfilerFunc, compileReport, translateBioIDs, emptyTableMessage, knitDataTable, visualizePCsByCondition)
```

